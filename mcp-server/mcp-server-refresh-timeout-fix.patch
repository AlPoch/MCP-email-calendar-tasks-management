--- a/mcp-server/src/index.ts
+++ b/mcp-server/src/index.ts
@@ -73,19 +73,32 @@
 // SSE Entrance
 app.get('/sse', async (req, res) => {
-    // FIX: Allow client to specify sessionId (via Query or Hrs) to support reconnection/persistence
-    const sessionId = (req.query.sessionId as string) cd s ||
-        (req.headers['x-mcp-session-id'] as string) ||
-        (req.headers['x-session-id'] as string) ||
-        Math.random().toString(36).substring(2, 12);
+    // NOTE:
+    // The MCP SDK (SSEServerTransport) generates its own sessionId during `start()`,
+    // which happens inside `server.connect(transport)`.
+    // If we register the transport under a different id, clients will POST /message
+    // with the SDK-generated sessionId and we'll fail to route messages (refresh => timeout).
+    const requestedSessionId = (req.query.sessionId as string) ||
+        (req.headers['x-mcp-session-id'] as string) ||
+        (req.headers['x-session-id'] as string);
     const baseUrl = getBaseUrl(req);
-    const endpoint = `${baseUrl}/message?sessionId=${sessionId}`;
+    // IMPORTANT: pass the base message endpoint WITHOUT a sessionId;
+    // the SDK will emit the correct endpoint (with its sessionId) to the client.
+    const endpoint = `${baseUrl}/message`;

-    console.log(`[SSE] Session ${sessionId} starting. Endpoint: ${endpoint}`);
+    console.log(`[SSE] New Connection. ClientID: ${requestedSessionId || 'None'} -> Assigned: (pending)`);

     try {
         const transport = new SSEServerTransport(endpoint, res);
-        // IMPORTANT: The sessionId in the endpoint MUST match the key used in `transports`,
-        // otherwise /message lookups will fail with 404.
-        console.log(`[SSE] Transport registered with Session ID: ${sessionId}`);
-        transports.set(sessionId, transport);
-
-        res.on('close', () => {
-            console.log(`[SSE] Session ${sessionId} closed`);
-            transports.delete(sessionId);
-        });
-
-        await server.connect(transport);
+        // Start transport (writes SSE headers + emits endpoint)
+        await server.connect(transport);
+
+        // After connect/start the SDK sessionId is available
+        const sdkSessionId = (transport as any).sessionId as string | undefined;
+        const finalSessionId = sdkSessionId || requestedSessionId || Math.random().toString(36).substring(2, 12);
+
+        console.log(`[SSE] Transport registered with Session ID: ${finalSessionId}`);
+        transports.set(finalSessionId, transport);
+
+        res.on('close', () => {
+            console.log(`[SSE] Session ${finalSessionId} closed`);
+            transports.delete(finalSessionId);
+        });
     } catch (err) {
         console.error(`[SSE] Critical failure in session ${requestedSessionId || 'unknown'}:`, err);
         if (!res.headersSent) res.status(500).send('SSE Init Error');
     }
 });
@@ -105,11 +118,20 @@
 // POST /sse is used by some clients as a probe. Do NOT treat it as a message route.
 app.post('/sse', (req, res) => {
     console.log(`[REQ] POST /sse Probe detected from ${req.ip || req.socket?.remoteAddress || 'unknown'}`);
-    // No content; keeps clients from entering reconnect/error loops.
-    res.status(204).end();
+    // Keep it fast and explicit (some clients retry on 4xx):
+    // - 204 for "probe ok" is fine
+    // - if you see the client sending JSON-RPC here and stalling, change to 200 with a small JSON body.
+    res.status(204).end();
 });
